let axios = require("axios");
let http = require("./rest/http.js");
let Util = require("./util");
let Discord = require("discord.js");
let moment = require("moment");

let math = require("mathjs");
let fs = require("fs");
let path = require("path");
let config = require("../config.json")
const fetch = require("node-fetch");



/**
 * @param {Discord.Collection} messages Discord.js Collection (Javascript Map) of needed details for a transcript
 * @param {Discord.TextChannel} Channel Discord.js Textchannel
 * @param {Discord.Message} message Last Message of Channel
 * @returns {string} Returns a link for the transcript
 */

exports.generate = async function(message, messages, channel) {
     let json = `./transcripts/${channel.id}.json`;
     
       await fs.writeFileSync(path.join(__dirname, json), JSON.stringify({
				entities: {
					users: {},
					channels: {},
                    roles: {},
                    
                },
                messages: [],
                channel_name: channel.name,
                topic: channel.topic
            }));
            
            let datas = await JSON.parse(fs.readFileSync(path.join(__dirname, json)));
        await messages.forEach(async function (x){
            

            
               let xobj = {
            id: x.id,
			author: x.author.id,
			content: x.content,
			time: x.createdTimestamp,
			embeds: [],
			attachments: [...x.attachments.values()]
        } 

        x.embeds.forEach(x => {
            const embeds = Object.assign({}, x);

            xobj.embeds.push(embeds);

        })
		
		
        datas.messages.push(xobj);

        datas.entities.users[x.author.id] = {
            avatar: x.author.displayAvatarURL(),
			username: x.author.username,
			discriminator: x.author.discriminator,
			badge: x.author.bot ? 'bot' : null
        }

        message.mentions.members.each(m => datas.entities.users[m.id] = { 
			avatar: m.user.displayAvatarURL(),
			username: m.user.username,
			discriminator: m.user.discriminator,
			badge: m.user.bot ? 'bot' : null
		});

		x.mentions.channels.each(c => datas.entities.channels[c.id] = { 
			name: c.name
		});

		x.mentions.roles.each(r => datas.entities.roles[r.id] = {
			name: r.name,
			color: r.color === 0 ? 7506394 : r.color
		});


        });

       await fs.writeFileSync(path.join(__dirname, `./transcripts/${channel.id}.json`), JSON.stringify(datas));


        let body = await JSON.parse(fs.readFileSync(path.join(__dirname, json)));
        
        let endpoint = `${config.base_2}/new?id=${channel.id}`;
       

		

let rr = await fetch(encodeURI(endpoint), {
			method: 'post',
			body: JSON.stringify(body),
			headers: { 'Content-Type': 'application/json' },
        }).then(res => res.text());

        let returned = rr.split(" ");
        let id = returned[0];
        let url = returned[1];
        console.log(returned);



        
            
	
        


        let link = await Util.GenerateURL(id);


        

        return link;




        


        

        
}


/**
 * @description Get a Generated Transcript via ID
 * @param {Discord.Message} msg Current Message object
 * @param {string} key Id of the transcript
 */

exports.getTranscript = async function(msg, key) {
    
    let request = await http.get(`${config.cloudflare_worker}/transcripts/get?id=${key}`);
    
        let attachment = new Discord.MessageAttachment(join(__dirname, request.url), `Transcript ID: ${key}`);

        return msg.channel.send(`Transcript ID: ${key}`, attachment);
    
    
}


