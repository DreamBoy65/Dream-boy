"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HAnimeAPI = void 0;
const tslib_1 = require("tslib");
const node_fetch_1 = tslib_1.__importDefault(require("node-fetch"));
const HAnimeSearch_1 = require("./HAnimeSearch");
const APITags_1 = require("./api-types/APITags");
const HAnimeVideo_1 = require("./HAnimeVideo");
const abort_controller_1 = tslib_1.__importDefault(require("abort-controller"));
const tag_aliases = {
    '3-d': '3d',
    'big breasts': 'big boobs',
    'large breasts': 'big boobs',
    'large boobs': 'big boobs',
    'big boob': 'big boobs',
    'large boob': 'big boobs',
    'large breast': 'big boobs',
    'huge boobs': 'big boobs',
    'huge boob': 'big boobs',
    'huge breast': 'big boobs',
    'huge breasts': 'big boobs',
    'blowjob': 'blow job',
    'bj': 'blow job',
    'breast job': 'boob job',
    'breastjob': 'boob job',
    'boobjob': 'boob job',
    'cream pie': 'creampie',
    'footjob': 'foot job',
    'futa': 'futanari',
    'gang bang': 'gangbang',
    'handjob': 'hand job',
    'lolicon': 'loli',
    'mindbreak': 'mind break',
    'neko mimi': 'nekomimi',
    'kemonomimi': 'nekomimi',
    'kemono mimi': 'nekomimi',
    'netorare': 'ntr',
    'point of view': 'pov',
    'point-of-view': 'pov',
    'rim job': 'rimjob',
    'rim-job': 'rimjob',
    'schoolgirl': 'school girl',
    'school-girl': 'school girl',
    'shotacon': 'shota',
    'soft core': 'softcore',
    'swim suit': 'swimsuit',
    'otoko': 'trap',
    'otokonoko': 'trap',
    'josou': 'trap',
    'otoko noko': 'trap',
    'otoko no musume': 'trap',
    'uncen': 'uncensored',
    'water sports': 'watersports',
    'water-sports': 'watersports',
    'xray': 'x-ray',
    'x ray': 'x-ray'
};
class HAnimeAPI {
    constructor(options) {
        this.options = options;
        this.options = options !== null && options !== void 0 ? options : {};
        if (!this.options.timeout)
            this.options.timeout = 5000;
        if (!this.options.fetch_options)
            this.options.fetch_options = {};
    }
    static get_path(url) {
        // reversed engineerd from function getPath in hanime webpack bundle
        if (!url)
            return '';
        if (url.startsWith('/'))
            return url;
        const real_url = url.replace(/http[s]{0,1}:\/\//, '').replace(/i\d\.wp\.com\//, '');
        const hostname = real_url.split('/')[0];
        return real_url.replace(hostname, '');
    }
    static jetpack_url(url, quality = 100, width_that_doesnt_actually_do_anything, height, cdn) {
        // reverse engineered from function jetpackUrl in hanime webpack bundle
        // remind me to never try this ever again
        if (!url)
            return '';
        const path = this.get_path(url);
        const real_path = height ? `${path}?quality=${quality}&h=${height}` : `${path}?quality=${quality}`;
        if (/\/archived-assets-\d+\./.test(url)) {
            const hostname = url.replace(/http[s]:\/\//, '').split('/')[0];
            const segment = hostname.split('.')[0].split('-').pop();
            return `https://i1.wp.com/archived-assets-${segment}.imageg.top${real_path}`;
        }
        if (cdn === 'cps') {
            const domains = ['https://i0.wp.com/ba.alphafish.top', 'https://i1.wp.com/ba.apperoni.top', 'https://i2.wp.com/ba.balley.top'];
            return domains[Math.floor(Math.random()) * domains.length] + real_path;
        }
        let domain = 'https://i1.wp.com/da.imageg.top';
        if (cdn === 'default-avatar')
            domain = 'https://i0.wp.com/ba.alphafish.top';
        return domain + real_path;
    }
    static get_image_url(url, quality = 100, cdn) {
        return this.jetpack_url(url, quality, null, null, cdn);
    }
    get_fetch_options(options) {
        var _a, _b, _c;
        return Object.assign({}, this.options.fetch_options, options, {
            headers: Object.assign({}, (_b = (_a = this.options.fetch_options) === null || _a === void 0 ? void 0 : _a.headers) !== null && _b !== void 0 ? _b : {}, (_c = options.headers) !== null && _c !== void 0 ? _c : {})
        });
    }
    get_tags_from_search(query) {
        const tags = new Set();
        APITags_1.APITags.forEach(tag => {
            const regex = new RegExp(`\\b${tag}\\b`, 'ig');
            query = query.replace(regex, () => {
                tags.add(tag);
                return '';
            });
        });
        Object.entries(tag_aliases).forEach(([alias, tag]) => {
            const regex = new RegExp(`\\b${alias}\\b`, 'ig');
            query = query.replace(regex, () => {
                tags.add(tag);
                return '';
            });
        });
        return [query.replace(/\s+/g, ' '), [...tags]];
    }
    async search(config_or_query, config) {
        var _a, _b;
        let api_config;
        if (typeof config_or_query == 'string') {
            let tags = [];
            if ((_a = config === null || config === void 0 ? void 0 : config.auto_tag) !== null && _a !== void 0 ? _a : true)
                [config_or_query, tags] = this.get_tags_from_search(config_or_query);
            api_config = Object.assign({
                search_text: config_or_query,
                tags_mode: 'AND',
                brands: [],
                blacklist: [],
                order_by: 'created_at_unix',
                ordering: 'desc'
            }, config, {
                tags: [...new Set([...tags, ...((_b = config === null || config === void 0 ? void 0 : config.tags) !== null && _b !== void 0 ? _b : [])])],
            });
        }
        else {
            api_config = Object.assign({
                tags: [],
                tags_mode: 'AND',
                brands: [],
                blacklist: [],
                order_by: 'created_at_unix',
                ordering: 'desc'
            }, config_or_query);
        }
        return new HAnimeSearch_1.HAnimeSearch(await this.api_search(api_config));
    }
    async api_search(config) {
        const controller = new abort_controller_1.default();
        const timeout = setTimeout(() => controller.abort(), this.options.timeout);
        const result = await node_fetch_1.default('https://search.htv-services.com/', this.get_fetch_options({
            method: 'POST',
            body: JSON.stringify(config),
            headers: {
                'Content-Type': 'application/json'
            },
            signal: controller.signal
        }));
        clearTimeout(timeout);
        return result.json();
    }
    async get_video(video) {
        const slug = typeof video == 'string' ? video : video.slug;
        const controller = new abort_controller_1.default();
        const timeout = setTimeout(() => controller.abort(), this.options.timeout);
        const video_info = await node_fetch_1.default(`https://members.hanime.tv/rapi/v7/video?id=${slug}`, this.get_fetch_options({
            method: 'GET',
            signal: controller.signal
        }));
        clearTimeout(timeout);
        return new HAnimeVideo_1.HAnimeVideo(await video_info.json());
    }
}
exports.HAnimeAPI = HAnimeAPI;
//# sourceMappingURL=HAnimeAPI.js.map